import os
import json
import asyncio
from fastapi import FastAPI, Request, Response, status
from fastapi.responses import StreamingResponse, JSONResponse, PlainTextResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import AsyncGenerator
import uvicorn

# Simulated ROS message imports (replace with actual ROS libraries if available)
# from sensor_msgs.msg import PointCloud2, LaserScan, Image
# from nav_msgs.msg import Odometry, Map

# ---------------- Environment Variables ----------------
SCOUT_DEVICE_IP = os.getenv("SCOUT_DEVICE_IP", "127.0.0.1")
SCOUT_ROSBRIDGE_PORT = int(os.getenv("SCOUT_ROSBRIDGE_PORT", "9090"))  # For WebSocket if implemented
HTTP_HOST = os.getenv("SCOUT_HTTP_HOST", "0.0.0.0")
HTTP_PORT = int(os.getenv("SCOUT_HTTP_PORT", "8000"))

# ---------------- API Models ----------------
class DriveCommand(BaseModel):
    speed: float
    direction: float

class GoalCommand(BaseModel):
    x: float
    y: float
    theta: float = 0.0

# ---------------- FastAPI App ----------------
app = FastAPI(
    title="SCOUT MINI Lite & Pro HTTP Device Driver",
    description="HTTP proxy/driver for AgileX Robotics SCOUT MINI Lite & Pro exposing sensor and control endpoints.",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"]
)

# ----------------- Simulated ROS Data Fetching -----------------
# In production, connect to ROS via rosbridge, roslibpy, or direct Python ROS client
async def get_lidar_data() -> dict:
    # Simulate point cloud data
    import random
    points = [[random.uniform(-5, 5), random.uniform(-5, 5), random.uniform(-1, 1)] for _ in range(200)]
    return {"point_cloud": points, "frame_id": "lidar_link"}

async def get_pose_data() -> dict:
    # Simulate odometry data
    return {
        "position": {"x": 1.23, "y": 4.56, "z": 0.0},
        "orientation": {"x": 0, "y": 0, "z": 0.707, "w": 0.707},
        "linear_velocity": 0.45,
        "angular_velocity": 0.02
    }

async def get_map_data() -> dict:
    # Simulate map data
    return {
        "map": [[0, 1, 0], [1, 1, 0], [0, 0, 0]],
        "resolution": 0.05,
        "origin": [0, 0, 0]
    }

async def send_drive_command(speed: float, direction: float) -> dict:
    # Simulate sending drive command
    return {"status": "success", "speed": speed, "direction": direction}

async def set_navigation_goal(x: float, y: float, theta: float) -> dict:
    # Simulate setting navigation goal
    return {"status": "goal_set", "x": x, "y": y, "theta": theta}

async def save_slam_map() -> dict:
    # Simulate SLAM map saving
    return {"status": "map_saved"}

# ----------------- Streaming Endpoint Helpers -----------------
async def lidar_streamer() -> AsyncGenerator[bytes, None]:
    while True:
        data = await get_lidar_data()
        chunk = (json.dumps(data) + "\n").encode("utf-8")
        yield chunk
        await asyncio.sleep(0.1)  # Stream at 10Hz

# ----------------- API Endpoints -----------------

@app.get("/lidar", summary="Get real-time LiDAR data as HTTP stream")
async def lidar_endpoint(request: Request):
    """
    Retrieves real-time scanning data from the LiDAR sensor, including point clouds.
    Streams as newline-delimited JSON over HTTP.
    """
    return StreamingResponse(lidar_streamer(), media_type="application/x-ndjson")

@app.post("/drive", summary="Send chassis control commands")
async def drive_endpoint(cmd: DriveCommand):
    """
    Sends chassis control commands to the robot. Specify speed and direction.
    """
    result = await send_drive_command(cmd.speed, cmd.direction)
    return JSONResponse(result)

@app.post("/goal", summary="Set navigation targets")
async def goal_endpoint(goal: GoalCommand):
    """
    Set navigation targets for the robot (x, y, theta).
    """
    result = await set_navigation_goal(goal.x, goal.y, goal.theta)
    return JSONResponse(result)

@app.get("/pose", summary="Get current odometry and position data")
async def pose_endpoint():
    """
    Returns current odometry and positional data of the robot.
    """
    data = await get_pose_data()
    return JSONResponse(data)

@app.get("/map", summary="Fetch latest mapping information")
async def map_endpoint():
    """
    Fetches the most recent mapping information generated by the robotâ€™s SLAM process.
    """
    data = await get_map_data()
    return JSONResponse(data)

@app.post("/slam", summary="Trigger SLAM map saving")
async def slam_endpoint():
    """
    Triggers the SLAM map saving process.
    """
    result = await save_slam_map()
    return JSONResponse(result)

@app.get("/", include_in_schema=False)
async def root():
    return PlainTextResponse("SCOUT MINI HTTP Device Driver Running")

# ----------------- Main Entrypoint -----------------
if __name__ == "__main__":
    uvicorn.run("main:app", host=HTTP_HOST, port=HTTP_PORT, reload=False)